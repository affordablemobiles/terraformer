// Copyright 2025 The Terraformer Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gcp

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/GoogleCloudPlatform/terraformer/terraformutils"
	"google.golang.org/api/artifactregistry/v1"
	"google.golang.org/api/compute/v1"
)

type ArtifactRegistryGenerator struct {
	GCPService
}

/**
 * @ai-generated Method generated by GitHub Copilot Agent.
 * @reviewed-by SJM
 */
func (g *ArtifactRegistryGenerator) InitResources() error {
	ctx := context.Background()
	artifactRegistryService, err := artifactregistry.NewService(ctx)
	if err != nil {
		return err
	}

	project := g.GetArgs()["project"].(string)
	parent := fmt.Sprintf("projects/%s", project)
	isGlobal := g.GetArgs()["region"].(compute.Region).Name == "" || g.GetArgs()["region"].(compute.Region).Name == "global"
	currentRegion := g.GetArgs()["region"].(compute.Region).Name

	// List locations
	locationsCall := artifactRegistryService.Projects.Locations.List(parent)
	err = locationsCall.Pages(ctx, func(page *artifactregistry.ListLocationsResponse) error {
		for _, location := range page.Locations {
			parts := strings.Split(location.Name, "/")
			locationId := parts[len(parts)-1]

			isMultiRegion := !strings.Contains(locationId, "-") // Heuristic: us, europe, asia vs us-central1

			if isGlobal {
				if !isMultiRegion {
					continue
				}
			} else {
				if locationId != currentRegion {
					continue
				}
			}

			g.createRepositories(ctx, artifactRegistryService, location.Name)
		}
		return nil
	})
	if err != nil {
		return err
	}

	return nil
}

/**
 * @ai-generated Method generated by GitHub Copilot Agent.
 * @reviewed-by SJM
 */
func (g *ArtifactRegistryGenerator) createRepositories(ctx context.Context, service *artifactregistry.Service, parent string) {
	repositoriesCall := service.Projects.Locations.Repositories.List(parent)
	err := repositoriesCall.Pages(ctx, func(page *artifactregistry.ListRepositoriesResponse) error {
		for _, repo := range page.Repositories {
			// repo.Name format: projects/{project}/locations/{location}/repositories/{repository_id}
			parts := strings.Split(repo.Name, "/")
			repositoryID := parts[len(parts)-1]
			location := parts[len(parts)-3]

			g.Resources = append(g.Resources, terraformutils.NewResource(
				repo.Name,
				repositoryID,
				"google_artifact_registry_repository",
				g.ProviderName,
				map[string]string{
					"project":       g.GetArgs()["project"].(string),
					"location":      location,
					"repository_id": repositoryID,
				},
				[]string{},
				map[string]interface{}{},
			))

			g.addIamMemberResourcesWithPolicyCheck(service, repo.Name, repositoryID, location)
		}
		return nil
	})
	if err != nil {
		log.Println(err)
	}
}

/**
 * @ai-generated Method generated by GitHub Copilot Agent.
 * @reviewed-by SJM
 */
func (g *ArtifactRegistryGenerator) addIamMemberResourcesWithPolicyCheck(service *artifactregistry.Service, resourceID, resourceName, location string) {
	policy, err := service.Projects.Locations.Repositories.GetIamPolicy(resourceID).OptionsRequestedPolicyVersion(3).Do()
	if err != nil {
		return
	}
	g.Resources = append(g.Resources, g.createIamMemberResources(resourceID, resourceName, location, policy.Bindings)...)
}

/**
 * @ai-generated Method generated by GitHub Copilot Agent.
 * @reviewed-by SJM
 */
func (g *ArtifactRegistryGenerator) createIamMemberResources(resourceID, resourceName, location string, bindings []*artifactregistry.Binding) []terraformutils.Resource {
	var resources []terraformutils.Resource
	resourceType := "google_artifact_registry_repository_iam_member"

	for _, binding := range bindings {
		attributes := map[string]string{
			"project":    g.GetArgs()["project"].(string),
			"location":   location,
			"repository": resourceName,
		}
		conditionTitle := ""
		conditionDescription := ""
		conditionExpression := ""
		if binding.Condition != nil {
			conditionTitle = binding.Condition.Title
			conditionDescription = binding.Condition.Description
			conditionExpression = binding.Condition.Expression
		}
		resources = append(resources, g.CreateIamMemberResources(resourceID, resourceName, resourceType, attributes, binding.Role, binding.Members, conditionTitle, conditionDescription, conditionExpression)...)
	}
	return resources
}
