// Copyright 2025 The Terraformer Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gcp

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/GoogleCloudPlatform/terraformer/terraformutils"
	"google.golang.org/api/cloudresourcemanager/v1"
	"google.golang.org/api/compute/v1"
	"google.golang.org/api/networksecurity/v1"
)

// NetworkSecurityGenerator generates Terraform resources for Google Cloud Network Security.
type NetworkSecurityGenerator struct {
	GCPService
}

// InitResources initializes the Network Security resources.
/**
 * @ai-generated Method generated by GitHub Copilot Agent.
 * @reviewed-by SJM
 */
func (g *NetworkSecurityGenerator) InitResources() error {
	project := g.GetArgs()["project"].(string)
	region := g.GetArgs()["region"].(compute.Region).Name
	ctx := context.Background()
	service, err := networksecurity.NewService(ctx)
	if err != nil {
		return fmt.Errorf("failed to create network security service: %w", err)
	}

	location := region
	if location == "" {
		location = "global"
	}

	parent := fmt.Sprintf("projects/%s/locations/%s", project, location)

	if err := g.initClientTlsPolicies(ctx, service, parent, project, location); err != nil {
		return err
	}
	if err := g.initServerTlsPolicies(ctx, service, parent, project, location); err != nil {
		return err
	}
	// Authorization Policies and Trust Configs are also part of Network Security
	// Trust Configs are referenced by Server TLS Policies
	if err := g.initAuthorizationPolicies(ctx, service, parent, project, location); err != nil {
		return err
	}

	return nil
}

func (g *NetworkSecurityGenerator) initAuthorizationPolicies(ctx context.Context, service *networksecurity.Service, parent, project, location string) error {
	req := service.Projects.Locations.AuthorizationPolicies.List(parent)
	if err := req.Pages(ctx, func(page *networksecurity.ListAuthorizationPoliciesResponse) error {
		for _, policy := range page.AuthorizationPolicies {
			parts := strings.Split(policy.Name, "/")
			policyName := parts[len(parts)-1]
			g.Resources = append(g.Resources, terraformutils.NewResource(
				policy.Name,
				policyName,
				"google_network_security_authorization_policy",
				g.ProviderName,
				map[string]string{
					"project":  project,
					"location": location,
					"name":     policyName,
				},
				[]string{},
				map[string]interface{}{},
			))
		}
		return nil
	}); err != nil {
		log.Println(err)
		return fmt.Errorf("failed to list authorization policies: %w", err)
	}
	return nil
}

func (g *NetworkSecurityGenerator) initClientTlsPolicies(ctx context.Context, service *networksecurity.Service, parent, project, location string) error {
	req := service.Projects.Locations.ClientTlsPolicies.List(parent)
	if err := req.Pages(ctx, func(page *networksecurity.ListClientTlsPoliciesResponse) error {
		for _, policy := range page.ClientTlsPolicies {
			parts := strings.Split(policy.Name, "/")
			policyName := parts[len(parts)-1]
			g.Resources = append(g.Resources, terraformutils.NewResource(
				policy.Name,
				policyName,
				"google_network_security_client_tls_policy",
				g.ProviderName,
				map[string]string{
					"project":  project,
					"location": location,
					"name":     policyName,
				},
				[]string{},
				map[string]interface{}{},
			))
		}
		return nil
	}); err != nil {
		log.Println(err)
		return fmt.Errorf("failed to list client tls policies: %w", err)
	}
	return nil
}

func (g *NetworkSecurityGenerator) initServerTlsPolicies(ctx context.Context, service *networksecurity.Service, parent, project, location string) error {
	req := service.Projects.Locations.ServerTlsPolicies.List(parent)
	if err := req.Pages(ctx, func(page *networksecurity.ListServerTlsPoliciesResponse) error {
		for _, policy := range page.ServerTlsPolicies {
			parts := strings.Split(policy.Name, "/")
			policyName := parts[len(parts)-1]
			g.Resources = append(g.Resources, terraformutils.NewResource(
				policy.Name,
				policyName,
				"google_network_security_server_tls_policy",
				g.ProviderName,
				map[string]string{
					"project":  project,
					"location": location,
					"name":     policyName,
				},
				[]string{},
				map[string]interface{}{},
			))
		}
		return nil
	}); err != nil {
		log.Println(err)
		return fmt.Errorf("failed to list server tls policies: %w", err)
	}
	return nil
}

// PostConvertHook implements the PostConvertHook interface.
func (g *NetworkSecurityGenerator) PostConvertHook() error {
	project := g.GetArgs()["project"].(string)
	ctx := context.Background()
	crmService, err := cloudresourcemanager.NewService(ctx)
	if err != nil {
		return fmt.Errorf("failed to create cloudresourcemanager service: %w", err)
	}

	projectResp, err := crmService.Projects.Get(project).Do()
	if err != nil {
		return fmt.Errorf("failed to get project details: %w", err)
	}
	projectNumber := strconv.FormatInt(projectResp.ProjectNumber, 10)

	for i, r := range g.Resources {
		if r.InstanceInfo.Type != "google_network_security_server_tls_policy" {
			continue
		}
		if mtlsPolicy, ok := r.Item["mtls_policy"]; ok {
			// mtls_policy is a list of maps
			if policies, ok := mtlsPolicy.([]interface{}); ok && len(policies) > 0 {
				for j, policy := range policies {
					if policyMap, ok := policy.(map[string]interface{}); ok {
						if trustConfig, ok := policyMap["client_validation_trust_config"].(string); ok {
							// Replace project number with project ID only if it matches the current project
							parts := strings.Split(trustConfig, "/")
							if len(parts) > 1 && parts[0] == "projects" && parts[1] == projectNumber {
								parts[1] = project
								policyMap["client_validation_trust_config"] = strings.Join(parts, "/")
								policies[j] = policyMap
							}
						}
					}
				}
				g.Resources[i].Item["mtls_policy"] = policies
			}
		}
	}
	return nil
}
